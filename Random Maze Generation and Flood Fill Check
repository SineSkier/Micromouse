//Name: MM Maze - Build
//Author: Dillon Mills
//Purpose: Randomly build a 16x16 maze to test MicroMouse algorithms.

#include <stdio.h>
#include <time.h>
#include <stdlib.h>
//c++ library
#include <conio.h>

void clearArray(int b[16][16][4]);
void generateRandomMaze(int b[16][16][4]);
void matchCells(int b[16][16][4]);
bool initiateFloodFill(int b[16][16][4], int c[16][16]);
void floodFill(int b[16][16][4], int c[16][16], int, int);
void printMaze(int b[16][16][4]);
void printFloodFill(int c[16][16]);

//----------//----------//NOTES//----------//----------//

void main() {
	//----------//----------//INITIALIZATION//----------//----------//
	int b[16][16][4];	//maze
	int c[16][16];		//flood (consider combining with maze b[][][])
	int gen = 0;		//generation count
	int goodGen = 0;	//whether or not the maze is solvable
	clock_t tStart = clock(), tEnd = clock();	//starting and ending time
	srand(clock());    
	
	//----------//----------//MAZE GENERATION//----------//----------//
	
	while (!goodGen) {	//makes sure maze is solvable
		
		clearArray(b);
		generateRandomMaze(b);
		goodGen = initiateFloodFill(b, c);
		
		//----------//Debugging//----------//
		//code to help debug
	
		//Print Info//
		//prints time elapsed, generation count, and goodSeed value to console
		system("cls");
		tEnd = clock();
		printf("Time:\t\t%.2f\n", (double)(tEnd - tStart)/1000);
		printf("Generation:\t%d\n", gen++);
		printMaze(b);
		printf("\n\n");
		printFloodFill(c);

		/*printf("\n\n");
		for (int i = 15; i >= 0; i--) {
			for (int j = 0; j < 16; j++) {
				printf("%d ", b[i][j][0] + b[i][j][1] + b[i][j][2] + b[i][j][3]);	//wall count
			}
			printf("\n");
		}*/
		_getch();
	}
}

void clearArray(int b[16][16][4]) {
	//Clean Slate//
	//starts the maze without having any walls anywhere
	for (int i = 0; i < 16; i++) {
		for (int j = 0; j < 16; j++) {
			for (int k = 0; k < 4; k++) {
				b[i][j][k] = 0;
			}
		}
	}
}

void generateRandomMaze(int b[16][16][4]) {
	//----------//Walls//----------//
	//build a random maze
	for (int i = 0; i < 16; i++) {
		for (int j = 0; j < 16; j++) {
			//randomize each side of each cell
			for (int k = 2; k < 4; k++) {
				b[i][j][k] = (rand()%3)%2;
			}
		}
	}

	//----------//Constants//----------//
	//After the maze is randomly generated, these constants are placed
	
	//Center Walls//
	//makes the center squares have walls on all sides
	for (int i = 7; i <= 8; i++) {
		for (int j = 7; j <= 8; j++) {
			for (int k = 0; k < 4; k++) {
				b[i][j][k] = 1;
			}
		}
	}

	//Center Opening//
	//places center wall opening
	switch (rand()%8) {
		case 0: b[7][7][3] = 0; break;
		case 1: b[7][7][2] = 0; break;
		case 2: b[7][8][2] = 0; break;
		case 3: b[7][8][1] = 0; break;
		case 4: b[8][8][1] = 0; break;
		case 5: b[8][8][0] = 0; break;
		case 6: b[8][7][0] = 0; break;
		case 7: b[8][7][3] = 0; break;
	}

	//Border//
	//make the edges have walls
	for (int i = 0; i < 16; i++) {
		b[0][i][2] = 1;
		b[15][i][0] = 1;
		b[i][0][3] = 1;
		b[i][15][1] = 1;
	}
	
	//Corners//
	//places the starting positions in the four corners
	b[0][0][0] = 0;
	b[0][0][1] = 1;
	b[0][0][2] = 1;
	b[0][0][3] = 1;
	b[0][1][3] = 1;
	b[1][0][2] = 0;
	b[0][15][0] = 1;
	b[0][15][1] = 1;
	b[0][15][2] = 1;
	b[0][15][3] = 0;
	b[0][14][1] = 0;
	b[1][15][2] = 1;
	b[15][0][0] = 1;
	b[15][0][1] = 0;
	b[15][0][2] = 1;
	b[15][0][3] = 1;
	b[15][1][3] = 0;
	b[14][0][0] = 1;
	b[15][15][0] = 1;
	b[15][15][1] = 1;
	b[15][15][2] = 0;
	b[15][15][3] = 1;
	b[15][14][1] = 1;
	b[14][15][0] = 0;

	matchCells(b);

	//Pegs//
	//makes sure a wall is on every peg
	for (int i = 0; i < 16; i++) {
		for (int j = 0; j < 16; j++) {
			if ((i > 0) && (j > 0)) {
				if (!(b[i][j][3] + b[i][j][2] + b[i - 1][j - 1][0] + b[i - 1][j - 1][1])) {
					switch (rand()%4) {
						case 0: b[i][j][3] = 1;			break;
						case 1: b[i][j][2] = 1;		break;
						case 2: b[i - 1][j - 1][0] = 1;		break;
						case 3: b[i - 1][j - 1][1] = 1;	break;
					}
				}
			}
		}
	}

	matchCells(b);
}

void matchCells(int b[16][16][4]) {
	//Matching//
	//makes sure each cell has the same walls as the adjacent cells
	for (int i = 0; i < 16; i++) {
		for (int j = 0; j < 16; j++) {
			if (i > 0 && b[i - 1][j][0]) {
				b[i][j][2] = 1;
			}
			if (i < 15 && b[i + 1][j][2]) {
				b[i][j][0] = 1;
			}
			if (j > 0 && b[i][j - 1][1]) {
				b[i][j][3] = 1;
			}
			if (j < 15 && b[i][j + 1][3]) {
				b[i][j][1] = 1;
			}
		}
	}
}

bool initiateFloodFill(int b[16][16][4], int c[16][16]) {
	//----------//Flood//----------//
	//test random maze with flood logic

	//Reset//
	//fills all flood array spaces with -1
	for (int k = 0; k < 16; k++) {
		for (int l = 0; l < 16; l++) {
			c[k][l] = -1;
		}
	}

	//Center//
	//fills the four goal flood array spaces with 0
	c[7][7] = 0;
	c[7][8] = 0;
	c[8][7] = 0;
	c[8][8] = 0;

	//Floodfill//
	//fills the flood array with values using flood fill logic
	for (int i = 7; i <= 8; i++) {
		for (int j = 7; j <= 8; j++) {
			floodFill(b, c, i, j);
		}
	}
	
	//Check//
	//checks if all four corners can reach the center
	if ((c[0][0] != -1) && (c[0][15] != -1) && (c[15][0] != -1) && (c[15][15] != -1)) {
		return 1;
	}
	return 0;
}

/*Flood-fill (node, target-color, replacement-color):
 1. If target-color is equal to replacement-color, return.
 2. If the color of node is not equal to target-color, return.
 3. Set the color of node to replacement-color.
 4. Perform Flood-fill (one step to the west of node, target-color, replacement-color).
    Perform Flood-fill (one step to the east of node, target-color, replacement-color).
    Perform Flood-fill (one step to the north of node, target-color, replacement-color).
    Perform Flood-fill (one step to the south of node, target-color, replacement-color).
 5. Return.*/

void floodFill(int b[16][16][4], int c[16][16], int i, int j) {
	if (i < 15 && c[i + 1][j] == -1 && !b[i][j][0] && !b[i + 1][j][2]) {
		c[i + 1][j] = c[i][j] + 1;
		floodFill(b, c, i + 1, j);
	}
	if (i > 0 && c[i - 1][j] == -1 && !b[i][j][2] && !b[i - 1][j][0]) {
		c[i - 1][j] = c[i][j] + 1;
		floodFill(b, c, i + 1, j);
	}
	if (j < 15 && c[i][j + 1] == -1 && !b[i][j][1] && !b[i][j + 1][3]) {
		c[i][j + 1] = c[i][j] + 1;
		floodFill(b, c, i, j + 1);
	}
	if (j > 0 && c[i][j - 1] == -1 && !b[i][j][3] && !b[i][j - 1][1]) {
		c[i][j - 1] = c[i][j] + 1;
		floodFill(b, c, i, j - 1);
	}
}

void printMaze(int b[16][16][4]) {
	//Print Maze//
	//prints visual representation of maze
	printf(" _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _");
	for (int i = 15; i >= 0; i--) {
		printf("\n|");
		for (int j = 0; j < 16; j++) {
			
			//visual representation
			if (b[i][j][2]) {
				printf("_");
			}
			else {
				printf(" ");
			}
			if (b[i][j][1]) {
				printf("|");
			}
			else {
				printf(" ");
			}

			//printf("%d\t",c[i][j]);	//flood value
		}
	}
}

/*char wall[16] = {(char)32, (char)32, (char)32, (char)192, (char)32, (char)179, (char)218, (char)195, 
					 (char)32, (char)217, (char)196, (char)193, (char)191, (char)180, (char)194, (char)197};*/

void printFloodFill(int c[16][16]) {
	for (int i = 15; i >= 0; i--) {
		for (int j = 0; j < 16; j++) {
			if (c[i][j] < 0 || c[i][j] > 9) {
				printf(" %d", c[i][j]);
			}
			else {
				printf("  %d", c[i][j]);
			}
		}
		printf("\n");
	}
}
