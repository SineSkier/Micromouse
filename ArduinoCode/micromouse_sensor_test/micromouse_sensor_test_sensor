byte sensorPin[5] = {0, 1, 2, 3, 4};  // left, leftdiag, center, rightdiag, right
int sensorValue[5];
long offset[5];

byte threshold = -10;

void sensorSetup() {
  int iterations = 1000;
  byte time = 2;  // seconds
  for (byte i = 0; i < 5; i++) {  // reset offset values
    offset[i] = 0;
  }
  
  for (int i = 0; i < iterations; i++) {  // make 'iteration' number of readings
    for (byte i = 0; i < 5; i++) {  // add up all the readings over the defined time
      offset[i] += analogRead(sensorPin[i]);
    }
    delay(time*1000/iterations);
  }
  for (byte i = 0; i < 5; i++) {  // divide by the number of iterations to get the average
    offset[i] /= iterations;
  }
  
  for (byte i = 0; i < 5; i++) {  // print all offsets
    Serial.println(offset[i]);
  }
}

boolean sensorReadL() {
  return (analogRead(sensorPin[0]) - offset[0]) > threshold;  // will return 1 for wall or 0 for space
}

boolean sensorReadF() {
  return (analogRead(sensorPin[3]) - offset[3]) > threshold;
}

boolean sensorReadR(){
  return (analogRead(sensorPin[5]) - offset[5]) > threshold;
}

void senseWall(byte dir, byte row, byte col, char m[SIZE][SIZE][5]) {
  m[row][col][(dir + 3)%4] = sensorReadL();
  m[row][col][dir] = sensorReadF();
  m[row][col][(dir + 1)%4] = sensorReadR();
}
